{
  "kubernetes-cluster.md": "# The Kubernetes Cluster I Shouldn't Have Built\n\nThis is the story of when I was a young, innocent programmer. Fancy buzzwords like *Kubernetes*, *Docker*, and *Firebase* sounded magical to me â€” so of course, I had to use them.\n\nIn the summer of 2024, I was tasked with scraping data of about 6,600 doctors from **Practo.com** (an online healthcare platform where doctors and clinics are listed). One of my professors needed this data for a survey. The initial problem statement was simple:\n\n> Scrape doctor data from 6 cities across 6 specializations. (That's 36 queries total.)\n\n## Initial Approach\n\nThis looked like a straightforward task. Just reverse-engineer Practo's APIs, loop through those 36 queries, save the results as JSON, and merge them later. I had done API reverse-engineering before, so this didn't feel like a challenge.\n\nSo I wrote the code.\n\n![Code screenshot](./kubernetes/ray-so-export.png)\n*(Yes, I used `let` instead of `var` for `response` â€” I was young.)*\n\nI ran it. Within 2 minutes, Practo rate-limited me.\n\n**Challenge #1: How do I bypass this rate limit?**\n\nMy \"lazy\" solution: rerun the code whenever it crashed. Steve Jobs once said he'd only hire lazy people because they find shortcuts. I told myself this was one of those moments.\n\nIt *kinda* worked. But scraping all 6,600 doctors took two full days. Each API call only returned 10 doctors at a time â€” paginated. Those two days were hell. I had to babysit my laptop to make sure the program didn't stop. My poor laptop worked nonstop for 48 hours.\n\nI gave the data to my professor. A few weeks later, she came back:\n\n> \"Now scrape reviews for each doctor.\"\n\nAlarm bells. That meant 6,600 API calls â€” ten times more than before. By proportion, this would take **20 days**. For 20 days, my laptop couldn't shut down, couldn't unplug, couldn't rest. That wasn't sustainable.\n\nI asked my college CS department if I could SSH into one of their lab computers. They refused, giving me one of their Windows 10 computers. Luckily, my professor managed to arrange 5 lab PCs for me â€” but I had to physically go there to check progress. Pain.\n\nThen I stumbled upon [this video by Harkirat Singh](https://www.youtube.com/watch?v=v06AYk-MnQ). He had a similar issue with scraping and rate limits. His solution? **Masterâ€“Worker architecture**: workers (any machine) take jobs from a master, possibly for a reward.\n\nI thought: *Perfect! I'll get workers from AWS EKS. Master can be a Firebase serverless function. Data in Firestore.*\n\nHere's what I built:\n\n![Architecture diagram](./kubernetes/Screenshot%20from%202025-10-04%2022-44-41.png)\n\nThe DB stored `doctorId` and `isReviewScraped`. Workers asked the master for tasks, and the master assigned pending ones.\n\n**Optimization:** Instead of sending one task per request, I batched 30 tasks to reduce latency.\n\nI separated master and worker logic, dockerized the worker, pushed it to Docker Hub, deployed the master on Firebase (with `minInstances = 1` to avoid cold starts). Then I wrote `deployment.yaml`, spun up an **EKS cluster with 16 t2 instances**, and hit \"Deploy.\"\n\nTo my surprise, all data was scraped in ~4 hours. From 20 days â†’ 4 hours. I felt victorious.\n\nNext day, AWS sent me a â‚¹1700 (~$20) bill. My professor happily paid. I thought this was costly.\n\nSo why is this post titled the way it is?\n\n## The Plot Twist\n\nWe had to repeat scraping every week for different cities. One day, while reading logs, I noticed something weird:\n\nMultiple workers were scraping the **same doctorId**. Then I realized **all workers were scraping all doctorIds**.\n\nThat meant:\n\n* A **single EC2 instance** could've done the entire job in 4 hours.\n* My laptop took 2 days, but EC2 only 4 hours. Why?\n* If rate limits were IP-based, why did EC2 scale so much better?\n\nSo many questions.\n\n## The Answer\n\nTurns out Firestore was the culprit. It suffered from **race conditions**.\n\nNetwork variance between identical EC2 instances is minimal. So when multiple workers requested tasks almost simultaneously (`Î”t < 250ms` by my guess), Firestore lagged in propagating updates (~1s delay). Result: the same tasks were handed out multiple times.\n\nIn short: Firestore isn't built for this type of locking.\n\n## The (Real) Solution\n\n* Firebase has no built-in locking.\n* Serverless functions are stateless, so semaphores don't help.\n* Trying to implement semaphores in Firestore just led to more race conditions.\n\nOnly real solution: **SQL databases**. They have built-in locks. No nonsense.\n\n## But Why Was One EC2 Instance Faster Than My Laptop?\n\nMy laptop's bandwidth was shared between scraping, YouTube, browsing, maybe some gaming. All those micro-delays added up. The EC2 instance had a dedicated, stable network â€” hence much faster scraping.\n\n---\n\n### Lessons learned\n\nI learned that before scaling up your architecture, you should first make sure there are no inefficiencies in the current setup. In my case, I could have achieved the same ~4-hour performance by simply renting a single EC2 instance â€” at a much lower cost and without the hassle of setting up an entire EKS cluster.",
  "ai-vibe-coding.md": "# AI and Vibe Coding\n\nI've been heavily using AI in my projects for the last three months. From ChatGPT's web app to agent modes in Cursor. I've developed some strong opinions about where AI should and *shouldn't* be used.\n\n---\n\n## Where AI **Shouldn't** Be Used\n\nIf you're building software that will have more than one user, you shouldn't vibe code.\n\nTwo months ago, my brother asked me to create a simple mobile app. It was basically a todo app but with custom logic, reminders, and categorization. It had just 3 screens:\n\n1.  Todos listed in categories with checkboxes (reset every 24 hours).\n2.  Clicking a category shows all todos in that category (todos can be updated/deleted here).\n3.  A screen to add more categories.\n\nPretty simple, right?\n\nI tried completely vibe coding this app without writing a single line myself. I used Cursor. It *kinda* worked, but the app was super buggy. It didn't even \"logically reason\" that todos needed to be saved. There were many such silly bugs. which I don't remember.\n\nYou could say I was lazy with prompting. I literally typed things like:\n> \"Please save stuff man!!\"\n\nâ€¦and expected AI to just figure it out.\n\nWhen I finally looked at the codebase, it was an **absolute shitshow**.\n\n![img1](./ai-vibe-coding/img1.png)\n*(634 fucking lines in `index.tsx`)*\n\n![img2](./ai-vibe-coding/img2.png)\n*(8 `useState` declarations in one place)*\n\nPlease bring me tissue paper, I'm crying ðŸ˜­. For such a simple app, this was the amount of chaos I had to see.\n\n---\n\n## Where AI **Can/Should** Be Used\n\n### Use Case 1: Debugging\n\nLet's say you hit a bug in an unknown territory, or you're just too lazy to debug it. This is where AI shines.\n\nAsk Cursor:\n> \"Hey, I'm facing this bug. These are the steps to reproduce it.\"\n\nIt'll scan your codebase and tell you the reason. But then â€” **stop there**. Don't let Cursor solve the bug. AI solutions often don't remove the root cause.\n\nUse your own brain (yes, the same brain you use to prompt) to fix the issue properly.\n\n---\n\n### Use Case 2: UI Generation\n\nThis works great for small to medium projects. AI is *very good* at building UI.\n\nWith just a single prompt, it can generate a usable interface. My sweet spot:\n- I describe the UI (layout, elements, state interactions).\n- AI writes the JSX and CSS.\n- I handle the actual JS logic (API calls, state management etc).\n\n![img3](./ai-vibe-coding/img3.png)\n\nThe screenshot above is from my site [khushalsindhav.com](https://khushalsindhav.com), **completely made by AI**. It took ~12 prompts in total. I was literally playing Counter-Strike 2 while AI coded for me.\n\nBonus: I got responsive pages done in ~3 prompts each. ðŸ¤¯\n\n---\n\n### Use Case 3: Tab Completion (Very Important!)\n\nAlways use Cursor's tab complete. I realized I can't live without it.\n\nMy Cursor subscription ended 2 days ago. I thought, \"let's try coding without it â€” after all, â‚¹1700 ($20) is expensive.\"\n\nDay 1: I was building my portfolio site in React. React is bread and butter for me. I didn't *struggle*, but I noticed my productivity drop to about **0.8x**. Honestly, I expected it to drop to 0.5x. The smaller drop was because most of the time I was writing CSS, where tab completion doesn't help much.\n\nDay 2: I was working on a React Native project. I'm not as familiar with React Native. My productivity dropped **3â€“4x**. Even in React, I'm sure it would've been at least 2x slower.\n\nWhy? Because every time I created a new file like `Component.tsx`, I had to manually write things like:\n\n```tsx\nimport React from \"react\";\nimport { Text, View } from \"react-native\";\n\nexport default function Component() {\n  return <View><Text>Hello</Text></View>;\n}\n```\n\n## How will I use AI now?\n\n1.  Cursor Tab Complete -> Must have\n2.  Agent mode to do some easy changes. I will carefully review this changes.\n3.  Agent mode to scaffold UI.\n4.  Vibe Coding for Projects I can't justify giving time but still want to do."
}